# setup up output raster to match input raster
names(filenames)<-sub("_categorical", "", names(filenames))
fullnames <- as.character(filenames[match(vnames, names(filenames))])
goodfiles <- file.access(fullnames) == 0
if(!all(goodfiles)) stop(paste("ERROR: the following image files are missing:", paste(fullnames[!goodfiles], collapse = ", ")))
if(nvars.final < 1) MESS = FALSE
if(nvars.final == 1) MOD = FALSE #because you can make a mess with one predictor but not a mod
######################################
# get spatial reference info from existing image file
gi <- GDALinfo(fullnames[1])
dims <- as.vector(gi)[1:2]
ps <- as.vector(gi)[6:7]
ll <- as.vector(gi)[4:5]
pref <- attr(gi, "projection")
RasterInfo = raster(fullnames[1])
RasterInfo@file@datanotation <- "FLT4S"
NAval <- -3.399999999999999961272e+38
#To remove use of the Raster package I need to see if rgdal handles area or point correctly
if(!is.na(match("AREA_OR_POINT=Point", attr(gi, "mdata")))){
xx <- RasterInfo  #this shifts by a half pixel
nrow(xx) <- nrow(xx) - 1
ncol(xx) <- ncol(xx) - 1
rs <- res(xx)
xmin(RasterInfo) <- xmin(RasterInfo) - 0.5 * rs[1]
xmax(RasterInfo) <- xmax(RasterInfo) - 0.5 * rs[1]
ymin(RasterInfo) <- ymin(RasterInfo) + 0.5 * rs[2]
ymax(RasterInfo) <- ymax(RasterInfo) + 0.5 * rs[2]
}
# setting tile size
MB.per.row <- dims[2] * nvars * 32 / 8 / 1000 / 1024
if(MESS) MB.per.row <- MB.per.row * 8 #use more blocks for mess
nrows <- min(round(tsize / MB.per.row), dims[1])
bs <- c(nrows,dims[2])
chunksize <- bs[1] * bs[2]
tr <- blockSize(RasterInfo, chunksize = chunksize)
FactorInd <- which(!is.na(match(vnames, names(factor.levels))), arr.ind = TRUE)
library(parallel)
#create some temporary folders
if(make.p.tif) dir.create(file.path(out$input$output.dir,"ProbTiff"))
if(make.binary.tif) dir.create(file.path(out$input$output.dir, "BinTiff"))
if(MESS) dir.create(file.path(out$input$output.dir,"MESSTiff"))
if(MOD)  dir.create(file.path(out$input$output.dir,"ModTiff"))
if(out$input$ResidMaps) dir.create(file.path(out$input$output.dir,"ResidTiff"))
tile.start<-seq(from=1,to=tr$n,by=ceiling(tr$n/(detectCores()-1)))
outfile.p = file.path(out$input$output.dir, "ProbTiff","_prob_map.tif")
outfile.bin = file.path(out$input$output.dir, "BinTiff","_bin_map.tif")
#Start parRaster
nToDo = ceiling(tr$n/(detectCores() - 1))
ScriptPath = out$input$ScriptPath
train.dat = out$dat$ma$train$dat
residSmooth = out$mods$auc.output$residual.smooth.fct
template = out$dat$input$ParcTemplate
maDir = out$input$ma.name
source(paste0(file.path(ScriptPath),"/pred.fct.r",sep=''))
source(paste0(file.path(ScriptPath),"/chk.libs.r",sep=''))
source(paste0(file.path(ScriptPath),"/CalcMESS.r",sep=''))
if(!is.null(residSmooth)) source(paste0(file.path(ScriptPath),"/Pred.Surface.R",sep=''))
chk.libs(Model)
tile.start
start.tile = 4383
#for the last set we have to adjust tr$n based on the number of remaining tiles
if((start.tile + nToDo) > tr$n) nToDo = tr$n - start.tile + 1
#have to hack in to change the extent for writting sections to seperate files because crop crashes for large files
start.val <- xyFromCell(RasterInfo, cellFromRowCol(RasterInfo, row=ifelse((start.tile+nToDo) > tr$n, nrow(RasterInfo), (tr$row[(start.tile+nToDo)]-1)),
col=1))-.5*res(RasterInfo)[2]
end.val <- xyFromCell(RasterInfo, cellFromRowCol(RasterInfo, row = tr$row[start.tile], col = ncol(RasterInfo))) + .5 * res(RasterInfo)[2]
RasterInfo@extent@ymin <- start.val[1, 2]
RasterInfo@extent@ymax <- end.val[1, 2]
RasterInfo@nrows = as.integer(sum(tr$nrows[start.tile:(start.tile + nToDo - 1)]))
outfile.p <- file.path(paste(substr(outfile.p, 1, (nchar(outfile.p) - 4)), ifelse(start.tile == 1, "", start.tile), ".tif", sep = ""))
#finding a folder that's been created so we can keep the user updated on the progress of creating the files
if(make.p.tif){
outtext <- paste(substr(outfile.p,1,(nchar(outfile.p)-4)),".txt",sep="")
} else {
if(make.binary.tif){
outtext <- paste(substr(outfile.bin,1,(nchar(outfile.bin)-4)),".txt",sep="")
} else{
if(MESS){
out.file<-sub("prob","mess",outfile.p)
outtext <- paste(substr(out.file,1,(nchar(out.file)-4)),".txt",sep="")
}
}
}
# capture.output(cat(paste(nToDo,"tiles to do\n")),file=outtext,append=TRUE)
if(make.binary.tif) outfile.bin <- (sub("ProbTiff", "BinTiff", sub("prob", "bin", outfile.p)))
#start up any rasters we need
if(make.p.tif){
continuousRaster <- raster(RasterInfo)
continuousRaster <- writeStart(continuousRaster, filename = outfile.p, overwrite = TRUE) #I should really change these so the datatypes make sense for each product
}
if(make.binary.tif) {
binaryRaster <- raster(RasterInfo)
binaryRaster <- writeStart(binaryRaster, filename = outfile.bin, overwrite = TRUE)
}
if(MESS){
MessRaster <- raster(RasterInfo)
MessRaster <- writeStart(MessRaster, filename = sub("ProbTiff", "MESSTiff", sub("prob", "mess", outfile.p)), overwrite = TRUE)
if(MOD){
ModRaster <- raster(RasterInfo)
if(MOD) ModRaster <- writeStart(ModRaster, filename = sub("ProbTiff", "ModTiff", sub("prob", "MoD", outfile.p)), overwrite = TRUE)
}
train.dat <- train.dat[ ,match(vnames.final.mod, names(train.dat))]
#order the training data so that we can consider the first and last row  only in mess calculations
for(k in 1:nvars.final) train.dat[ ,k] <- sort(train.dat[ ,k])
}
HasTemplate = TRUE
TemplateMask = NA
templateRast <- try(raster(template), silent = TRUE)
if(class(templateRast)=="try-error"){ #so that we can move a session folder to a new computer
template <- file.path(dirname(maDir), basename(template))
templateRast <- try(raster(template), silent = TRUE)
if(class(templateRast) == "try-error") HasTemplate = FALSE
}
###actual predictions
# for (i in start.tile:min(start.tile + nToDo - 1, length(tr$row))){
for (i in start.tile:(start.tile + 2)){
# capture.output(cat(paste("starting tile", i, Sys.time(), "\n")), file = outtext, append = TRUE)
#alter the write start location because we always start at position 1
writeLoc <- ifelse((start.tile - 1) == 0, tr$row[i], tr$row[i] - sum(tr$nrows[1:(start.tile-1)]))
if(HasTemplate){
TemplateMask <- getValuesBlock(templateRast, row = tr$row[i], nrows = tr$nrows[i])
if(all(is.na(TemplateMask))){
#if the template is completely NA values, don't read in any other data
temp <- rep(NA, times = tr$nrow[i] * dims[2])
if(MESS) pred.rng<-rep(NA,length(temp))
}
}
if(!HasTemplate | !all(is.na(TemplateMask))){
temp <- data.frame(matrix(ncol = nvars.final, nrow = tr$nrows[i] * dims[2]))
# Setting the first predictor equal to NA where ever the mask is NA
# fill temp data frame
for(k in 1:nvars.final) temp[,k] <- getValuesBlock(raster(fullnames[match(vnames.final.mod[k], vnames)]), row = tr$row[i], nrows = tr$nrows[i])
#so we won't write out predictions here
if(HasTemplate) temp[is.na(TemplateMask), 1] <- NA
names(temp) <- vnames.final.mod
if(MESS){
pred.rng <- rep(NA, nrow(temp))
names(pred.rng) <- NA
if(any(complete.cases(temp))){
MessVals <- CalcMESS(temp[complete.cases(temp), ], train.dat = train.dat)
pred.rng[complete.cases(temp)] <- MessVals[ ,2]
names(pred.rng)[complete.cases(temp)] <- MessVals[ ,1]
}
}
if(length(vnames) == 1) names(temp) = vnames
temp[temp == NAval] <- NA # replace missing values #
if(sum(!is.na(factor.levels))){
factor.cols <- match(names(factor.levels), names(temp))
if(sum(!is.na(factor.cols)) > 0){
for(j in 1:length(factor.cols)){
if(!is.na(factor.cols[j])){
temp[,factor.cols[j]] <- factor(temp[, factor.cols[j]], levels = factor.levels[[j]]$number, labels = factor.levels[[j]]$class)
}
}
}
}
}
ifelse(sum(complete.cases(temp)) == 0,  # does not calculate predictions if all predictors in the region are na
preds <- matrix(data = NA, nrow = dims[2], ncol = tr$nrows[i]),
preds <- t(matrix(pred.fct(model, temp, Model), ncol = dims[2], byrow = T)))
if(MESS){
MessRaster <- writeValues(MessRaster, pred.rng, writeLoc)
if(is.null(names(pred.rng))) names(pred.rng) <- NA
if(MOD) ModRaster <- writeValues(ModRaster, names(pred.rng), writeLoc)
}
if(make.binary.tif) binaryRaster <- writeValues(binaryRaster, (preds > thresh), writeLoc)
if(make.p.tif) continuousRaster <- writeValues(continuousRaster, preds, writeLoc)
} #end of the big for loop
end.seq <- c(tr$row, dims[1] + 1)
if(make.p.tif) continuousRaster <- writeStop(continuousRaster)
if(make.binary.tif) writeStop(binaryRaster)
if(MESS) writeStop(MessRaster)
if(MOD){
writeStop(ModRaster)
d <- data.frame(as.integer(seq(1:length(train.dat))), names(train.dat))
names(d) = c("Value","Class")
ModRaster@file@datanotation <- "INT1U"
write.dbf(d, sub(".tif", ".tif.vat.dbf", ModRaster@file@name), factor2char = TRUE, max_nchar = 254)
}
if(!is.null(residSmooth)) Pred.Surface(object = raster(outfile.p), model = residSmooth, filename = (sub("ProbTiff", "ResidTiff", sub("prob", "resid", outfile.p))), NAval = NAval)
rgdal::GDALinfo('E:/Users/engelstad/USGS/data/goutweed/ProbTiff/_prob_map.tif')
rgdal::GDALinfo('E:/Users/engelstad/USGS/data/goutweed/ProbTiff/_prob_map4383.tif')
rgdal::GDALinfo('E:/Users/engelstad/USGS/data/goutweed/ProbTiff/_prob_map4383.tif')
#Default all the maps to off in case an arg is forgottten on the command line.
resid=F
mpt=T
mbt=F
mess=F
load('E:/Users/engelstad/USGS/data/goutweed/modelWorkspace_edited.RData')
# Need to add paths to wherever your local copies of these files.
source('C:/Users/pederengelstad/.vistrails/userpackages/sahm_2_1_1/pySAHM/Resources/R_Modules/Experimental/proc.tiff.mapproduction.r', local = F)
source('C:/Users/pederengelstad/.vistrails/userpackages/sahm_2_1_1/pySAHM/Resources/R_Modules/Experimental/parRaster_mapproduction.r')
library(rgdal)
library(raster)
library(parallel)
library(gdalUtils)
library(foreign)
out$input$MESS = mess
MOD = mess
MESS = mess
out$input$ResidMaps = resid
out$input$make.binary.tif = mbt
out$input$make.p.tif = mpt
model = out$mods$final.mod
vnames = names(out$dat$ma$train$dat)[-1]
tif.dir = out$dat$tif.dir$dname
filenames = out$dat$tif.ind
factor.levels = out$dat$factor.levels
make.binary.tif = out$input$make.binary.tif
thresh = out$mods$auc.output$thresh
make.p.tif = out$input$make.p.tif
outfile.p = paste(out$dat$bname,"_prob_map.tif",sep="")
outfile.bin = paste(out$dat$bname,"_bin_map.tif",sep="")
tsize = 50.0
NAval = -3000
fnames = out$dat$tif.names
Model = out$input$script.name
########################################
# Start of proc.tiff function
if(is.null(factor.levels)) factor.levels <- NA
MESS = MOD = out$input$MESS
if(is.null(thresh)) thresh <- 0.5
nvars <- length(vnames)
vnames.final.mod <- out$mods$vnames
nvars.final <- length(vnames.final.mod)
# setup up output raster to match input raster
names(filenames)<-sub("_categorical", "", names(filenames))
fullnames <- as.character(filenames[match(vnames, names(filenames))])
goodfiles <- file.access(fullnames) == 0
if(!all(goodfiles)) stop(paste("ERROR: the following image files are missing:", paste(fullnames[!goodfiles], collapse = ", ")))
if(nvars.final < 1) MESS = FALSE
if(nvars.final == 1) MOD = FALSE #because you can make a mess with one predictor but not a mod
######################################
# get spatial reference info from existing image file
gi <- GDALinfo(fullnames[1])
dims <- as.vector(gi)[1:2]
ps <- as.vector(gi)[6:7]
ll <- as.vector(gi)[4:5]
pref <- attr(gi, "projection")
RasterInfo = raster(fullnames[1])
RasterInfo@file@datanotation <- "FLT4S"
NAval <- -3.399999999999999961272e+38
#To remove use of the Raster package I need to see if rgdal handles area or point correctly
if(!is.na(match("AREA_OR_POINT=Point", attr(gi, "mdata")))){
xx <- RasterInfo  #this shifts by a half pixel
nrow(xx) <- nrow(xx) - 1
ncol(xx) <- ncol(xx) - 1
rs <- res(xx)
xmin(RasterInfo) <- xmin(RasterInfo) - 0.5 * rs[1]
xmax(RasterInfo) <- xmax(RasterInfo) - 0.5 * rs[1]
ymin(RasterInfo) <- ymin(RasterInfo) + 0.5 * rs[2]
ymax(RasterInfo) <- ymax(RasterInfo) + 0.5 * rs[2]
}
# setting tile size
MB.per.row <- dims[2] * nvars * 32 / 8 / 1000 / 1024
if(MESS) MB.per.row <- MB.per.row * 8 #use more blocks for mess
nrows <- min(round(tsize / MB.per.row), dims[1])
bs <- c(nrows,dims[2])
chunksize <- bs[1] * bs[2]
tr <- blockSize(RasterInfo, chunksize = chunksize)
FactorInd <- which(!is.na(match(vnames, names(factor.levels))), arr.ind = TRUE)
library(parallel)
#create some temporary folders
if(make.p.tif) dir.create(file.path(out$input$output.dir,"ProbTiff"))
if(make.binary.tif) dir.create(file.path(out$input$output.dir, "BinTiff"))
if(MESS) dir.create(file.path(out$input$output.dir,"MESSTiff"))
if(MOD)  dir.create(file.path(out$input$output.dir,"ModTiff"))
if(out$input$ResidMaps) dir.create(file.path(out$input$output.dir,"ResidTiff"))
tile.start<-seq(from=1,to=tr$n,by=ceiling(tr$n/(detectCores()-1)))
outfile.p = file.path(out$input$output.dir, "ProbTiff","_prob_map.tif")
outfile.bin = file.path(out$input$output.dir, "BinTiff","_bin_map.tif")
#Start parRaster
nToDo = ceiling(tr$n/(detectCores() - 1))
ScriptPath = out$input$ScriptPath
train.dat = out$dat$ma$train$dat
residSmooth = out$mods$auc.output$residual.smooth.fct
template = out$dat$input$ParcTemplate
maDir = out$input$ma.name
source(paste0(file.path(ScriptPath),"/pred.fct.r",sep=''))
source(paste0(file.path(ScriptPath),"/chk.libs.r",sep=''))
source(paste0(file.path(ScriptPath),"/CalcMESS.r",sep=''))
if(!is.null(residSmooth)) source(paste0(file.path(ScriptPath),"/Pred.Surface.R",sep=''))
chk.libs(Model)
tile.start
start.tile = 4383
#for the last set we have to adjust tr$n based on the number of remaining tiles
if((start.tile + nToDo) > tr$n) nToDo = tr$n - start.tile + 1
#have to hack in to change the extent for writting sections to seperate files because crop crashes for large files
start.val <- xyFromCell(RasterInfo, cellFromRowCol(RasterInfo, row=ifelse((start.tile+nToDo) > tr$n, nrow(RasterInfo), (tr$row[(start.tile+nToDo)]-1)),
col=1))-.5*res(RasterInfo)[2]
end.val <- xyFromCell(RasterInfo, cellFromRowCol(RasterInfo, row = tr$row[start.tile], col = ncol(RasterInfo))) + .5 * res(RasterInfo)[2]
RasterInfo@extent@ymin <- start.val[1, 2]
RasterInfo@extent@ymax <- end.val[1, 2]
RasterInfo@nrows = as.integer(sum(tr$nrows[start.tile:(start.tile + nToDo - 1)]))
outfile.p <- file.path(paste(substr(outfile.p, 1, (nchar(outfile.p) - 4)), ifelse(start.tile == 1, "", start.tile), ".tif", sep = ""))
#finding a folder that's been created so we can keep the user updated on the progress of creating the files
if(make.p.tif){
outtext <- paste(substr(outfile.p,1,(nchar(outfile.p)-4)),".txt",sep="")
} else {
if(make.binary.tif){
outtext <- paste(substr(outfile.bin,1,(nchar(outfile.bin)-4)),".txt",sep="")
} else{
if(MESS){
out.file<-sub("prob","mess",outfile.p)
outtext <- paste(substr(out.file,1,(nchar(out.file)-4)),".txt",sep="")
}
}
}
# capture.output(cat(paste(nToDo,"tiles to do\n")),file=outtext,append=TRUE)
if(make.binary.tif) outfile.bin <- (sub("ProbTiff", "BinTiff", sub("prob", "bin", outfile.p)))
#start up any rasters we need
if(make.p.tif){
continuousRaster <- raster(RasterInfo)
continuousRaster <- writeStart(continuousRaster, filename = outfile.p, overwrite = TRUE) #I should really change these so the datatypes make sense for each product
}
if(make.binary.tif) {
binaryRaster <- raster(RasterInfo)
binaryRaster <- writeStart(binaryRaster, filename = outfile.bin, overwrite = TRUE)
}
if(MESS){
MessRaster <- raster(RasterInfo)
MessRaster <- writeStart(MessRaster, filename = sub("ProbTiff", "MESSTiff", sub("prob", "mess", outfile.p)), overwrite = TRUE)
if(MOD){
ModRaster <- raster(RasterInfo)
if(MOD) ModRaster <- writeStart(ModRaster, filename = sub("ProbTiff", "ModTiff", sub("prob", "MoD", outfile.p)), overwrite = TRUE)
}
train.dat <- train.dat[ ,match(vnames.final.mod, names(train.dat))]
#order the training data so that we can consider the first and last row  only in mess calculations
for(k in 1:nvars.final) train.dat[ ,k] <- sort(train.dat[ ,k])
}
HasTemplate = TRUE
TemplateMask = NA
templateRast <- try(raster(template), silent = TRUE)
if(class(templateRast)=="try-error"){ #so that we can move a session folder to a new computer
template <- file.path(dirname(maDir), basename(template))
templateRast <- try(raster(template), silent = TRUE)
if(class(templateRast) == "try-error") HasTemplate = FALSE
}
###actual predictions
# for (i in start.tile:min(start.tile + nToDo - 1, length(tr$row))){
for (i in start.tile:(start.tile + 2)){
# capture.output(cat(paste("starting tile", i, Sys.time(), "\n")), file = outtext, append = TRUE)
#alter the write start location because we always start at position 1
writeLoc <- ifelse((start.tile - 1) == 0, tr$row[i], tr$row[i] - sum(tr$nrows[1:(start.tile-1)]))
if(HasTemplate){
TemplateMask <- getValuesBlock(templateRast, row = tr$row[i], nrows = tr$nrows[i])
if(all(is.na(TemplateMask))){
#if the template is completely NA values, don't read in any other data
temp <- rep(NA, times = tr$nrow[i] * dims[2])
if(MESS) pred.rng<-rep(NA,length(temp))
}
}
if(!HasTemplate | !all(is.na(TemplateMask))){
temp <- data.frame(matrix(ncol = nvars.final, nrow = tr$nrows[i] * dims[2]))
# Setting the first predictor equal to NA where ever the mask is NA
# fill temp data frame
for(k in 1:nvars.final) temp[,k] <- getValuesBlock(raster(fullnames[match(vnames.final.mod[k], vnames)]), row = tr$row[i], nrows = tr$nrows[i])
#so we won't write out predictions here
if(HasTemplate) temp[is.na(TemplateMask), 1] <- NA
names(temp) <- vnames.final.mod
if(MESS){
pred.rng <- rep(NA, nrow(temp))
names(pred.rng) <- NA
if(any(complete.cases(temp))){
MessVals <- CalcMESS(temp[complete.cases(temp), ], train.dat = train.dat)
pred.rng[complete.cases(temp)] <- MessVals[ ,2]
names(pred.rng)[complete.cases(temp)] <- MessVals[ ,1]
}
}
if(length(vnames) == 1) names(temp) = vnames
temp[temp == NAval] <- NA # replace missing values #
if(sum(!is.na(factor.levels))){
factor.cols <- match(names(factor.levels), names(temp))
if(sum(!is.na(factor.cols)) > 0){
for(j in 1:length(factor.cols)){
if(!is.na(factor.cols[j])){
temp[,factor.cols[j]] <- factor(temp[, factor.cols[j]], levels = factor.levels[[j]]$number, labels = factor.levels[[j]]$class)
}
}
}
}
}
ifelse(sum(complete.cases(temp)) == 0,  # does not calculate predictions if all predictors in the region are na
preds <- matrix(data = NA, nrow = dims[2], ncol = tr$nrows[i]),
preds <- t(matrix(pred.fct(model, temp, Model), ncol = dims[2], byrow = T)))
if(MESS){
MessRaster <- writeValues(MessRaster, pred.rng, writeLoc)
if(is.null(names(pred.rng))) names(pred.rng) <- NA
if(MOD) ModRaster <- writeValues(ModRaster, names(pred.rng), writeLoc)
}
if(make.binary.tif) binaryRaster <- writeValues(binaryRaster, (preds > thresh), writeLoc)
if(make.p.tif) continuousRaster <- writeValues(continuousRaster, preds, writeLoc)
} #end of the big for loop
end.seq <- c(tr$row, dims[1] + 1)
if(make.p.tif) continuousRaster <- writeStop(continuousRaster)
if(make.binary.tif) writeStop(binaryRaster)
if(MESS) writeStop(MessRaster)
if(MOD){
writeStop(ModRaster)
d <- data.frame(as.integer(seq(1:length(train.dat))), names(train.dat))
names(d) = c("Value","Class")
ModRaster@file@datanotation <- "INT1U"
write.dbf(d, sub(".tif", ".tif.vat.dbf", ModRaster@file@name), factor2char = TRUE, max_nchar = 254)
}
if(!is.null(residSmooth)) Pred.Surface(object = raster(outfile.p), model = residSmooth, filename = (sub("ProbTiff", "ResidTiff", sub("prob", "resid", outfile.p))), NAval = NAval)
rgdal::GDALinfo('E:/Users/engelstad/USGS/data/goutweed/ProbTiff/_prob_map.tif')
rgdal::GDALinfo('E:/Users/engelstad/USGS/data/goutweed/ProbTiff/_prob_map4383.tif')
out$input
library(raster)
in.r = raster(file.path(paste0(dirname(dirname(in.rast)),'/ensemble_1st.tif',sep='')))
in.rast = 'E:/Users/engelstad/USGS/data/scratch/postprocessing_test/ensemble/mess_masked/ensemble_1st_masked.tif'
# Create threshold raster
out.rast = paste0(tools::file_path_sans_ext(in.rast), '_gte.tif', sep = '')
in.r = raster(file.path(paste0(dirname(dirname(in.rast)),'/ensemble_1st.tif',sep='')))
in.r@data@haveminmax
max(in.r[in.r!=32767])
max(test[test!=32767])
test = raster('E:/Users/engelstad/USGS/data/fountaingrass/fountaingrass/fountaingrass/ensemble/ensemble_1st.tif')
max(test[test!=32767])
?raster()
test = raster('E:/Users/engelstad/USGS/data/fountaingrass/fountaingrass/fountaingrass/ensemble/ensemble_1st.tif', values=T)
test@data
test@data@values
test@data@max
raster::cellStats(test[test!=32767], stat = max)
values(sample(test[test!=32767], size = 100))
rgdal::GDALinfo('E:/Users/engelstad/USGS/data/fountaingrass/fountaingrass/fountaingrass/ensemble/ensemble_1st.tif')
gdalUtils::gdalinfo(datasetname = 'E:/Users/engelstad/USGS/data/fountaingrass/fountaingrass/fountaingrass/ensemble/ensemble_1st.tif',
mm = T)
gdalUtils::gdalinfo(datasetname = 'E:/Users/engelstad/USGS/data/fountaingrass/fountaingrass/fountaingrass/ensemble/ensemble_1st.tif'
,stats = T)
gdalUtils::gdalinfo(datasetname = 'E:/Users/engelstad/USGS/data/fountaingrass/fountaingrass/fountaingrass/ensemble/ensemble_1st.tif'
,approx_stats = T)
stats = gdalUtils::gdalinfo(datasetname = 'E:/Users/engelstad/USGS/data/fountaingrass/fountaingrass/fountaingrass/ensemble/ensemble_1st.tif'
,approx_stats = T)
stats[grep(pattern = 'MAXIMUM',fixed = T)]
stats[grep(pattern = 'MAXIMUM',x = stats,fixed = T)]
grep('\d+', x = stats[grep(pattern = 'MAXIMUM',x = stats,fixed = T)], value = T)
grep('\\d+', x = stats[grep(pattern = 'MAXIMUM',x = stats,fixed = T)], value = T)
stringr::str_extract(pattern = '\\d+', string = stats[grep(pattern = 'MAXIMUM',x = stats,fixed = T)])
as.numeric(stringr::str_extract(pattern = '\\d+', string = stats[grep(pattern = 'MAXIMUM',x = stats,fixed = T)]))
in.r = raster(file.path(paste0(dirname(dirname(in.rast)),'/ensemble_1st.tif',sep='')))
as.numeric(stringr::str_extract(pattern = '\\d+', string = in.r[grep(pattern = 'MAXIMUM',x = in.r, fixed = T)]))
stats = gdalUtils::gdalinfo(datasetname = file.path(paste0(dirname(dirname(in.rast)),'/ensemble_1st.tif',sep=''))
,approx_stats = T)
stats
stats[grep(pattern = 'MAXIMUM',x = stats, fixed = T)]
as.numeric(stringr::str_extract(pattern = '\\d+', string = stats[grep(pattern = 'MAXIMUM',x = stats, fixed = T)]))
# Create threshold raster
out.rast = paste0(tools::file_path_sans_ext(in.rast), '_gte.tif', sep = '')
stats = gdalUtils::gdalinfo(datasetname = file.path(paste0(dirname(dirname(in.rast)),'/ensemble_1st.tif',sep=''))
,approx_stats = T)
max.val = as.numeric(stringr::str_extract(pattern = '\\d+', string = stats[grep(pattern = 'MAXIMUM',x = stats, fixed = T)]))
command = paste0(shQuote(py.path), ' ', shQuote(gdal.calc.path),
' -A ', shQuote(in.rast),
' --type=Byte --calc="1*(logical_and(A>=',ceiling(max.val/2)
,', A<100))" --co=COMPRESS=LZW --co=TILED=YES --NoDataValue=0.0 --overwrite --outfile=',
out.rast,
sep = '')
command = paste0(shQuote(pypath), ' ', shQuote(gdal.calc.path),
' -A ', shQuote(in.rast),
' --type=Byte --calc="1*(logical_and(A>=',ceiling(max.val/2)
,', A<100))" --co=COMPRESS=LZW --co=TILED=YES --NoDataValue=0.0 --overwrite --outfile=',
out.rast,
sep = '')
command
stats = gdalUtils::gdalinfo(datasetname = 'E:/Users/engelstad/USGS/data/fountaingrass/fountaingrass/fountaingrass/ensemble/ensemble_1st.tif'
,approx_stats = T)
stats
max.val = as.numeric(stringr::str_extract(pattern = '\\d+', string = stats[grep(pattern = 'MAXIMUM',x = stats, fixed = T)]))
max.val
install.packages("shiny")
install.packages("knitr")
install.packages("tidyverse")
install.packages("spatialEco")
install.packages("PresenceAbsence")
install.packages("randomForest")
install.packages("rgdal")
install.packages("gdalUtils")
install.packages("raster")
install.packages("taxize")
install.packages("spocc")
install.packages("rmarkdown")
install.packages(c("cluster", "ellipsis", "nlme", "processx", "sf"))
install.packages("markdown")
install.packages("rmarkdown")
library(git2r)
wd = "E:/Users/engelstad/GitHub"
dirs = list.dirs(wd, recursive = F)
for(d in dirs){
cat(d)
print(git2r::status(d))
}
install.packages("git2r")
library(git2r)
wd = "E:/Users/engelstad/GitHub"
dirs = list.dirs(wd, recursive = F)
for(d in dirs){
cat(d)
print(git2r::status(d))
}
install.packages(c("boot", "callr", "checkmate", "coda", "deldir", "digest", "dplyr", "haven", "hms", "sf", "vctrs"))
install.packages(c("callr", "clipr", "curl", "openssl", "processx", "quantreg", "raster", "rmarkdown"))
install.packages(c("crul", "deldir", "foreach", "foreign", "httr", "iterators", "nlme", "quantreg", "Rcpp", "rgeos", "sf", "spatialEco", "SpatialPack", "xml2"))
install.packages(c("DT", "flexdashboard", "kableExtra", "knitr", "leaflet", "magrittr", "rgdal", "shinyBS", "shinyWidgets", "sp"))
install.packages(c("rgdal", "shinyBS", "shinyWidgets", "sp"))
install.packages("bsplus")
install.packages("rsconnect")
setwd("E:/Users/engelstad/GitHub/inhabit_sandbox/")
rsconnect::deployApp(account = "engelstad",appName = "sandbox", appPrimaryDoc='sandbox.rmd', appSourceDoc = 'sandbox.rmd')
install.packages("shinydashboard")
install.packages("shinydashboardPlus")
